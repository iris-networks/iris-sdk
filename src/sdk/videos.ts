/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { videosDeleteRecording } from "../funcs/videosDeleteRecording.js";
import { videosDownload } from "../funcs/videosDownload.js";
import { videosGenerate } from "../funcs/videosGenerate.js";
import { videosGetCurrentSessionData } from "../funcs/videosGetCurrentSessionData.js";
import { videosGetFramesAndCaptions } from "../funcs/videosGetFramesAndCaptions.js";
import { videosGetMetadata } from "../funcs/videosGetMetadata.js";
import { videosGetRecordingData } from "../funcs/videosGetRecordingData.js";
import { videosGetStatus } from "../funcs/videosGetStatus.js";
import { videosGetThumbnail } from "../funcs/videosGetThumbnail.js";
import { videosList } from "../funcs/videosList.js";
import { videosSaveCurrentSession } from "../funcs/videosSaveCurrentSession.js";
import { StreamAcceptEnum, videosStream } from "../funcs/videosStream.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export { StreamAcceptEnum } from "../funcs/videosStream.js";

export class Videos extends ClientSDK {
  /**
   * List all recordings
   *
   * @remarks
   * Returns a list of all video recordings available in the system
   */
  async list(
    options?: RequestOptions,
  ): Promise<components.RecordingListResponseDto> {
    return unwrapAsync(videosList(
      this,
      options,
    ));
  }

  /**
   * Get recording metadata
   *
   * @remarks
   * Returns detailed metadata about a specific recording
   */
  async getMetadata(
    request: operations.GetRecordingMetadataRequest,
    options?: RequestOptions,
  ): Promise<components.RecordingResponseDto> {
    return unwrapAsync(videosGetMetadata(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete recording by ID
   *
   * @remarks
   * Permanently deletes a recording and all associated files. This operation cannot be undone. It removes all frames, captions, metadata, and the generated video file.
   */
  async deleteRecording(
    request: operations.DeleteRecordingRequest,
    options?: RequestOptions,
  ): Promise<components.DeleteRecordingResponseDto> {
    return unwrapAsync(videosDeleteRecording(
      this,
      request,
      options,
    ));
  }

  /**
   * Get video generation status
   *
   * @remarks
   * Returns the current status of video generation for a recording. This endpoint provides detailed information about the video generation process, including whether it is pending, in progress, completed, or failed. Additional information is provided based on the status, such as start time, completion time, file format, size, and error messages if applicable.
   */
  async getStatus(
    request: operations.GetVideoStatusRequest,
    options?: RequestOptions,
  ): Promise<components.VideoStatusResponseDto> {
    return unwrapAsync(videosGetStatus(
      this,
      request,
      options,
    ));
  }

  /**
   * Get recording thumbnail
   *
   * @remarks
   * Returns the thumbnail image for a recording as a PNG file. This is typically the first frame of the recording.
   */
  async getThumbnail(
    request: operations.GetRecordingThumbnailRequest,
    options?: RequestOptions,
  ): Promise<ReadableStream<Uint8Array>> {
    return unwrapAsync(videosGetThumbnail(
      this,
      request,
      options,
    ));
  }

  /**
   * Save current session as a recording
   *
   * @remarks
   * Saves the current active session as a video recording. This endpoint captures all screenshots collected during the session, stores them on disk, and initiates automatic video generation in the background. The video generation process happens asynchronously and can be monitored via the video-status endpoint. This recording captures both visual states and action contexts, creating a complete task record that can be analyzed, modified, or transformed into reusable automation workflows.
   */
  async saveCurrentSession(
    options?: RequestOptions,
  ): Promise<components.SaveSessionRecordingResponseDto> {
    return unwrapAsync(videosSaveCurrentSession(
      this,
      options,
    ));
  }

  /**
   * Get video data for current session
   *
   * @remarks
   * Returns the raw frames and captions for the current active session. This endpoint is primarily used for diagnostic purposes or custom video processing. Most clients should use the generated video file instead of raw frames.
   */
  async getCurrentSessionData(
    options?: RequestOptions,
  ): Promise<components.CurrentSessionVideoDataResponseDto> {
    return unwrapAsync(videosGetCurrentSessionData(
      this,
      options,
    ));
  }

  /**
   * Get video data for a specific recording
   *
   * @remarks
   * Returns the raw frames and captions for a specific recording. This endpoint is primarily used for replaying recordings in the UI.
   */
  async getRecordingData(
    request: operations.GetRecordingVideoDataRequest,
    options?: RequestOptions,
  ): Promise<components.SessionReplayDataResponseDto> {
    return unwrapAsync(videosGetRecordingData(
      this,
      request,
      options,
    ));
  }

  /**
   * Download recording as ZIP file
   *
   * @remarks
   * Downloads a recording as a ZIP archive containing all frames, captions, and metadata. This is useful for backup purposes or offline processing. For normal video playback, use the video endpoint instead.
   */
  async download(
    request: operations.DownloadRecordingRequest,
    options?: RequestOptions,
  ): Promise<ReadableStream<Uint8Array>> {
    return unwrapAsync(videosDownload(
      this,
      request,
      options,
    ));
  }

  /**
   * Generate a video from the recording frames
   *
   * @remarks
   * Creates a video file from the frames of a recording with customizable options. This endpoint allows you to specify frame rate, caption settings, output format, and quality level. By default, videos play at 0.2 frames per second (5 seconds per frame) to allow time to read the captions. Videos are generated asynchronously, and you can check the status using the video-status endpoint. Note that videos are also generated automatically when a recording is created, so this endpoint is mostly useful for regenerating with different settings. The generated video will have the correct duration with each screenshot displayed for the specified amount of time.
   */
  async generate(
    request: operations.GenerateVideoRequest,
    options?: RequestOptions,
  ): Promise<components.GenerateVideoResponseDto> {
    return unwrapAsync(videosGenerate(
      this,
      request,
      options,
    ));
  }

  /**
   * Stream the generated video file
   *
   * @remarks
   * Streams the generated video file for a recording. This endpoint can be used directly in video players, such as in an HTML5 video tag. By default, videos play at 0.2 frames per second (5 seconds per frame) to allow time to read the captions. If the video has not been generated yet, it will attempt to generate it on-demand. If generation is already in progress, it returns a status update instead of the video. The endpoint supports both streaming (default) and download modes. The video duration will be correctly calculated based on the frame rate and number of screenshots.
   */
  async stream(
    request: operations.StreamVideoRequest,
    options?: RequestOptions & { acceptHeaderOverride?: StreamAcceptEnum },
  ): Promise<operations.StreamVideoResponse> {
    return unwrapAsync(videosStream(
      this,
      request,
      options,
    ));
  }

  /**
   * Get frames and captions for editing
   *
   * @remarks
   * Returns all frames and their associated captions for a recording to be edited
   */
  async getFramesAndCaptions(
    request: operations.GetFramesAndCaptionsRequest,
    options?: RequestOptions,
  ): Promise<components.FramesAndCaptionsResponseDto> {
    return unwrapAsync(videosGetFramesAndCaptions(
      this,
      request,
      options,
    ));
  }
}
