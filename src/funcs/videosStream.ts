/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { IrisSDKCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { pathToFunc } from "../lib/url.js";
import { APIError } from "../models/errors/apierror.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { Result } from "../types/fp.js";

export enum StreamAcceptEnum {
  imageGif = "image/gif",
  videoMp4 = "video/mp4",
  videoWebm = "video/webm",
}

/**
 * Stream the generated video file
 *
 * @remarks
 * Streams the generated video file for a recording. This endpoint can be used directly in video players, such as in an HTML5 video tag. By default, videos play at 0.2 frames per second (5 seconds per frame) to allow time to read the captions. If the video has not been generated yet, it will attempt to generate it on-demand. If generation is already in progress, it returns a status update instead of the video. The endpoint supports both streaming (default) and download modes. The video duration will be correctly calculated based on the frame rate and number of screenshots.
 */
export async function videosStream(
  client: IrisSDKCore,
  request: operations.StreamVideoRequest,
  options?: RequestOptions & { acceptHeaderOverride?: StreamAcceptEnum },
): Promise<
  Result<
    operations.StreamVideoResponse,
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >
> {
  const parsed = safeParse(
    request,
    (value) => operations.StreamVideoRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return parsed;
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/api/videos/{id}/video")(pathParams);

  const query = encodeFormQuery({
    "download": payload.download,
  });

  const headers = new Headers({
    Accept: options?.acceptHeaderOverride
      || "image/gif;q=1, video/mp4;q=0.7, video/webm;q=0",
  });

  const context = {
    operationID: "streamVideo",
    oAuth2Scopes: [],

    resolvedSecurity: null,

    securitySource: null,
    retryConfig: options?.retries
      || client._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
  };

  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return requestRes;
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return doResult;
  }
  const response = doResult.value;

  const [result] = await M.match<
    operations.StreamVideoResponse,
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >(
    M.stream(200, operations.StreamVideoResponse$inboundSchema, {
      ctype: "video/mp4",
    }),
    M.stream(200, operations.StreamVideoResponse$inboundSchema, {
      ctype: "video/webm",
    }),
    M.stream(200, operations.StreamVideoResponse$inboundSchema, {
      ctype: "image/gif",
    }),
    M.bytes(202, operations.StreamVideoResponse$inboundSchema, {
      ctype: "image/gif",
    }),
    M.bytes(202, operations.StreamVideoResponse$inboundSchema, {
      ctype: "video/mp4",
    }),
    M.bytes(202, operations.StreamVideoResponse$inboundSchema, {
      ctype: "video/webm",
    }),
    M.fail([404, "4XX", 500, "5XX"]),
  )(response);
  if (!result.ok) {
    return result;
  }

  return result;
}
